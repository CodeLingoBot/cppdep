package cppdep

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

type Generator interface {
	// Match returns true if this generator counts path as an input file
	Match(path string) bool

	// OutputPaths lists all files generated by this Generator. inputFile may be ingored.
	OutputPaths(inputFile, outputDir string) []string

	// Generate executes the generator on a give input file. Certain types of Generators may
	// ignore inputFile if the have a fixed set of inputs. (Such a ShellGenerator)
	Generate(inputFile, outputDir string) error
}

type TypeGenerator struct {
	InputExt   string
	OutputExts []string
	Command    []string
}

var genHook func(input string)

func (g *TypeGenerator) Match(path string) bool {
	return strings.HasSuffix(path, g.InputExt)
}

func outputPrefix(inputFile, outputDir string) string {
	base := filepath.Base(inputFile)
	dotIndex := strings.LastIndex(base, ".")
	if dotIndex == -1 {
		return filepath.Join(outputDir, base)
	}
	return filepath.Join(outputDir, base[:dotIndex])
}

func (g *TypeGenerator) OutputPaths(inputFile, outputDir string) []string {
	prefix := outputPrefix(inputFile, outputDir)
	var outputPaths []string
	for _, outExt := range g.OutputExts {
		outputPaths = append(outputPaths, fmt.Sprintf("%s%s", prefix, outExt))
	}
	return outputPaths
}

func createEnvVarMap(inputFile, outputDir string) map[string]string {
	if in, err := filepath.Abs(inputFile); err == nil {
		inputFile = in
	}
	if out, err := filepath.Abs(outputDir); err == nil {
		outputDir = out
	}
	return map[string]string{
		"$CPPDEP_INPUT_DIR":     filepath.Dir(inputFile),
		"$CPPDEP_INPUT_FILE":    inputFile,
		"$CPPDEP_OUTPUT_DIR":    outputDir,
		"$CPPDEP_OUTPUT_PREFIX": outputPrefix(inputFile, outputDir),
	}
}

func (g *TypeGenerator) Generate(inputFile, outputDir string) error {
	td := createEnvVarMap(inputFile, outputDir)
	var transformedArgs []string
	for _, arg := range g.Command[1:] {
		for evar, value := range td {
			i := strings.Index(arg, evar)
			if i == -1 {
				continue
			}
			arg = fmt.Sprintf("%s%s%s", arg[:i], value, arg[i+len(evar):])
		}
		transformedArgs = append(transformedArgs, arg)
	}

	if !supressLogging {
		fmt.Printf("Generating:")
		for _, fn := range g.OutputPaths(inputFile, outputDir) {
			fmt.Printf(" %s", filepath.Base(fn))
		}
		fmt.Print("\n")
	}

	cmd := exec.Command(g.Command[0])
	cmd.Args = append(cmd.Args, transformedArgs...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

// ShellGenerator defines a generator that depends on the files listed in InputPaths, and by running the
// shell script file at ShellFilePath will generate the OutputFiles in a specified output directory. The
// $CWD for the execution of the shell file will always be the directory of that shell file.
type ShellGenerator struct {
	InputPaths    []string // These should be relative to the root of the src tree
	OutputFiles   []string // Just base filenames, not full paths
	ShellFilePath string   // Path to the shell file to execute, should be absolute path
}

func (g *ShellGenerator) Match(path string) bool {
	for _, inSuffix := range g.InputPaths {
		if strings.HasSuffix(path, inSuffix) {
			if len(path) == len(inSuffix) || path[len(path)-len(inSuffix)-1] == '/' {
				return true
			}
		}
	}
	return false
}

func (g *ShellGenerator) OutputPaths(inputFile, outputDir string) []string {
	var outputPaths []string
	for _, outBase := range g.OutputFiles {
		outputPaths = append(outputPaths, filepath.Join(outputDir, outBase))
	}
	return outputPaths
}

func (g *ShellGenerator) Generate(inputFile, outputDir string) error {
	cmd := exec.Command("sh", g.ShellFilePath)
	cmd.Env = os.Environ()
	for evar, val := range createEnvVarMap(g.ShellFilePath, outputDir) {
		cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", evar[1:], val))
	}
	cmd.Dir = filepath.Dir(g.ShellFilePath)
	if !supressLogging {
		fmt.Printf("Running Generate Script: %s\n", filepath.Base(g.ShellFilePath))
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
	}
	return cmd.Run()
}
